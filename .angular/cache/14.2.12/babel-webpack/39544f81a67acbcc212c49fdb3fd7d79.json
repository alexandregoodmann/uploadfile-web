{"ast":null,"code":"const EOL = \"\\n\";\n/**\n * \n * @param {array} jArray \n * @param {any} options \n * @returns \n */\n\nfunction toXml(jArray, options) {\n  let indentation = \"\";\n\n  if (options.format && options.indentBy.length > 0) {\n    indentation = EOL;\n  }\n\n  return arrToStr(jArray, options, \"\", indentation);\n}\n\nfunction arrToStr(arr, options, jPath, indentation) {\n  let xmlStr = \"\";\n  let isPreviousElementTag = false;\n\n  for (let i = 0; i < arr.length; i++) {\n    const tagObj = arr[i];\n    const tagName = propName(tagObj);\n    let newJPath = \"\";\n    if (jPath.length === 0) newJPath = tagName;else newJPath = `${jPath}.${tagName}`;\n\n    if (tagName === options.textNodeName) {\n      let tagText = tagObj[tagName];\n\n      if (!isStopNode(newJPath, options)) {\n        tagText = options.tagValueProcessor(tagName, tagText);\n        tagText = replaceEntitiesValue(tagText, options);\n      }\n\n      if (isPreviousElementTag) {\n        xmlStr += indentation;\n      }\n\n      xmlStr += tagText;\n      isPreviousElementTag = false;\n      continue;\n    } else if (tagName === options.cdataPropName) {\n      if (isPreviousElementTag) {\n        xmlStr += indentation;\n      }\n\n      xmlStr += `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;\n      isPreviousElementTag = false;\n      continue;\n    } else if (tagName === options.commentPropName) {\n      xmlStr += indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;\n      isPreviousElementTag = true;\n      continue;\n    } else if (tagName[0] === \"?\") {\n      const attStr = attr_to_str(tagObj[\":@\"], options);\n      const tempInd = tagName === \"?xml\" ? \"\" : indentation;\n      let piTextNodeName = tagObj[tagName][0][options.textNodeName];\n      piTextNodeName = piTextNodeName.length !== 0 ? \" \" + piTextNodeName : \"\"; //remove extra spacing\n\n      xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr}?>`;\n      isPreviousElementTag = true;\n      continue;\n    }\n\n    let newIdentation = indentation;\n\n    if (newIdentation !== \"\") {\n      newIdentation += options.indentBy;\n    }\n\n    const attStr = attr_to_str(tagObj[\":@\"], options);\n    const tagStart = indentation + `<${tagName}${attStr}`;\n    const tagValue = arrToStr(tagObj[tagName], options, newJPath, newIdentation);\n\n    if (options.unpairedTags.indexOf(tagName) !== -1) {\n      if (options.suppressUnpairedNode) xmlStr += tagStart + \">\";else xmlStr += tagStart + \"/>\";\n    } else if ((!tagValue || tagValue.length === 0) && options.suppressEmptyNode) {\n      xmlStr += tagStart + \"/>\";\n    } else if (tagValue && tagValue.endsWith(\">\")) {\n      xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>`;\n    } else {\n      xmlStr += tagStart + \">\";\n\n      if (tagValue && indentation !== \"\" && (tagValue.includes(\"/>\") || tagValue.includes(\"</\"))) {\n        xmlStr += indentation + options.indentBy + tagValue + indentation;\n      } else {\n        xmlStr += tagValue;\n      }\n\n      xmlStr += `</${tagName}>`;\n    }\n\n    isPreviousElementTag = true;\n  }\n\n  return xmlStr;\n}\n\nfunction propName(obj) {\n  const keys = Object.keys(obj);\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    if (key !== \":@\") return key;\n  }\n}\n\nfunction attr_to_str(attrMap, options) {\n  let attrStr = \"\";\n\n  if (attrMap && !options.ignoreAttributes) {\n    for (let attr in attrMap) {\n      let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);\n      attrVal = replaceEntitiesValue(attrVal, options);\n\n      if (attrVal === true && options.suppressBooleanAttributes) {\n        attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}`;\n      } else {\n        attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}=\"${attrVal}\"`;\n      }\n    }\n  }\n\n  return attrStr;\n}\n\nfunction isStopNode(jPath, options) {\n  jPath = jPath.substr(0, jPath.length - options.textNodeName.length - 1);\n  let tagName = jPath.substr(jPath.lastIndexOf(\".\") + 1);\n\n  for (let index in options.stopNodes) {\n    if (options.stopNodes[index] === jPath || options.stopNodes[index] === \"*.\" + tagName) return true;\n  }\n\n  return false;\n}\n\nfunction replaceEntitiesValue(textValue, options) {\n  if (textValue && textValue.length > 0 && options.processEntities) {\n    for (let i = 0; i < options.entities.length; i++) {\n      const entity = options.entities[i];\n      textValue = textValue.replace(entity.regex, entity.val);\n    }\n  }\n\n  return textValue;\n}\n\nmodule.exports = toXml;","map":{"version":3,"names":["EOL","toXml","jArray","options","indentation","format","indentBy","length","arrToStr","arr","jPath","xmlStr","isPreviousElementTag","i","tagObj","tagName","propName","newJPath","textNodeName","tagText","isStopNode","tagValueProcessor","replaceEntitiesValue","cdataPropName","commentPropName","attStr","attr_to_str","tempInd","piTextNodeName","newIdentation","tagStart","tagValue","unpairedTags","indexOf","suppressUnpairedNode","suppressEmptyNode","endsWith","includes","obj","keys","Object","key","attrMap","attrStr","ignoreAttributes","attr","attrVal","attributeValueProcessor","suppressBooleanAttributes","substr","attributeNamePrefix","lastIndexOf","index","stopNodes","textValue","processEntities","entities","entity","replace","regex","val","module","exports"],"sources":["/home/alexandre/projetos/uploadfile-web/node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js"],"sourcesContent":["const EOL = \"\\n\";\n\n/**\n * \n * @param {array} jArray \n * @param {any} options \n * @returns \n */\nfunction toXml(jArray, options) {\n    let indentation = \"\";\n    if (options.format && options.indentBy.length > 0) {\n        indentation = EOL;\n    }\n    return arrToStr(jArray, options, \"\", indentation);\n}\n\nfunction arrToStr(arr, options, jPath, indentation) {\n    let xmlStr = \"\";\n    let isPreviousElementTag = false;\n\n    for (let i = 0; i < arr.length; i++) {\n        const tagObj = arr[i];\n        const tagName = propName(tagObj);\n        let newJPath = \"\";\n        if (jPath.length === 0) newJPath = tagName\n        else newJPath = `${jPath}.${tagName}`;\n\n        if (tagName === options.textNodeName) {\n            let tagText = tagObj[tagName];\n            if (!isStopNode(newJPath, options)) {\n                tagText = options.tagValueProcessor(tagName, tagText);\n                tagText = replaceEntitiesValue(tagText, options);\n            }\n            if (isPreviousElementTag) {\n                xmlStr += indentation;\n            }\n            xmlStr += tagText;\n            isPreviousElementTag = false;\n            continue;\n        } else if (tagName === options.cdataPropName) {\n            if (isPreviousElementTag) {\n                xmlStr += indentation;\n            }\n            xmlStr += `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;\n            isPreviousElementTag = false;\n            continue;\n        } else if (tagName === options.commentPropName) {\n            xmlStr += indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;\n            isPreviousElementTag = true;\n            continue;\n        } else if (tagName[0] === \"?\") {\n            const attStr = attr_to_str(tagObj[\":@\"], options);\n            const tempInd = tagName === \"?xml\" ? \"\" : indentation;\n            let piTextNodeName = tagObj[tagName][0][options.textNodeName];\n            piTextNodeName = piTextNodeName.length !== 0 ? \" \" + piTextNodeName : \"\"; //remove extra spacing\n            xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr}?>`;\n            isPreviousElementTag = true;\n            continue;\n        }\n        let newIdentation = indentation;\n        if (newIdentation !== \"\") {\n            newIdentation += options.indentBy;\n        }\n        const attStr = attr_to_str(tagObj[\":@\"], options);\n        const tagStart = indentation + `<${tagName}${attStr}`;\n        const tagValue = arrToStr(tagObj[tagName], options, newJPath, newIdentation);\n        if (options.unpairedTags.indexOf(tagName) !== -1) {\n            if (options.suppressUnpairedNode) xmlStr += tagStart + \">\";\n            else xmlStr += tagStart + \"/>\";\n        } else if ((!tagValue || tagValue.length === 0) && options.suppressEmptyNode) {\n            xmlStr += tagStart + \"/>\";\n        } else if (tagValue && tagValue.endsWith(\">\")) {\n            xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>`;\n        } else {\n            xmlStr += tagStart + \">\";\n            if (tagValue && indentation !== \"\" && (tagValue.includes(\"/>\") || tagValue.includes(\"</\"))) {\n                xmlStr += indentation + options.indentBy + tagValue + indentation;\n            } else {\n                xmlStr += tagValue;\n            }\n            xmlStr += `</${tagName}>`;\n        }\n        isPreviousElementTag = true;\n    }\n\n    return xmlStr;\n}\n\nfunction propName(obj) {\n    const keys = Object.keys(obj);\n    for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        if (key !== \":@\") return key;\n    }\n}\n\nfunction attr_to_str(attrMap, options) {\n    let attrStr = \"\";\n    if (attrMap && !options.ignoreAttributes) {\n        for (let attr in attrMap) {\n            let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);\n            attrVal = replaceEntitiesValue(attrVal, options);\n            if (attrVal === true && options.suppressBooleanAttributes) {\n                attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}`;\n            } else {\n                attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}=\"${attrVal}\"`;\n            }\n        }\n    }\n    return attrStr;\n}\n\nfunction isStopNode(jPath, options) {\n    jPath = jPath.substr(0, jPath.length - options.textNodeName.length - 1);\n    let tagName = jPath.substr(jPath.lastIndexOf(\".\") + 1);\n    for (let index in options.stopNodes) {\n        if (options.stopNodes[index] === jPath || options.stopNodes[index] === \"*.\" + tagName) return true;\n    }\n    return false;\n}\n\nfunction replaceEntitiesValue(textValue, options) {\n    if (textValue && textValue.length > 0 && options.processEntities) {\n        for (let i = 0; i < options.entities.length; i++) {\n            const entity = options.entities[i];\n            textValue = textValue.replace(entity.regex, entity.val);\n        }\n    }\n    return textValue;\n}\nmodule.exports = toXml;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}