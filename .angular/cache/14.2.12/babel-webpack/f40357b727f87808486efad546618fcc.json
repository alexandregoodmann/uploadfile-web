{"ast":null,"code":"'use strict'; ///@ts-check\n\nconst util = require('../util');\n\nconst xmlNode = require('./xmlNode');\n\nconst readDocType = require(\"./DocTypeReader\");\n\nconst toNumber = require(\"strnum\");\n\nconst regx = '<((!\\\\[CDATA\\\\[([\\\\s\\\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\\\/)(NAME)\\\\s*>))([^<]*)'.replace(/NAME/g, util.nameRegexp); //const tagsRegx = new RegExp(\"<(\\\\/?[\\\\w:\\\\-\\._]+)([^>]*)>(\\\\s*\"+cdataRegx+\")*([^<]+)?\",\"g\");\n//const tagsRegx = new RegExp(\"<(\\\\/?)((\\\\w*:)?([\\\\w:\\\\-\\._]+))([^>]*)>([^<]*)(\"+cdataRegx+\"([^<]*))*([^<]+)?\",\"g\");\n\nclass OrderedObjParser {\n  constructor(options) {\n    this.options = options;\n    this.currentNode = null;\n    this.tagsNodeStack = [];\n    this.docTypeEntities = {};\n    this.lastEntities = {\n      \"apos\": {\n        regex: /&(apos|#39|#x27);/g,\n        val: \"'\"\n      },\n      \"gt\": {\n        regex: /&(gt|#62|#x3E);/g,\n        val: \">\"\n      },\n      \"lt\": {\n        regex: /&(lt|#60|#x3C);/g,\n        val: \"<\"\n      },\n      \"quot\": {\n        regex: /&(quot|#34|#x22);/g,\n        val: \"\\\"\"\n      }\n    };\n    this.ampEntity = {\n      regex: /&(amp|#38|#x26);/g,\n      val: \"&\"\n    };\n    this.htmlEntities = {\n      \"space\": {\n        regex: /&(nbsp|#160);/g,\n        val: \" \"\n      },\n      // \"lt\" : { regex: /&(lt|#60);/g, val: \"<\" },\n      // \"gt\" : { regex: /&(gt|#62);/g, val: \">\" },\n      // \"amp\" : { regex: /&(amp|#38);/g, val: \"&\" },\n      // \"quot\" : { regex: /&(quot|#34);/g, val: \"\\\"\" },\n      // \"apos\" : { regex: /&(apos|#39);/g, val: \"'\" },\n      \"cent\": {\n        regex: /&(cent|#162);/g,\n        val: \"¢\"\n      },\n      \"pound\": {\n        regex: /&(pound|#163);/g,\n        val: \"£\"\n      },\n      \"yen\": {\n        regex: /&(yen|#165);/g,\n        val: \"¥\"\n      },\n      \"euro\": {\n        regex: /&(euro|#8364);/g,\n        val: \"€\"\n      },\n      \"copyright\": {\n        regex: /&(copy|#169);/g,\n        val: \"©\"\n      },\n      \"reg\": {\n        regex: /&(reg|#174);/g,\n        val: \"®\"\n      },\n      \"inr\": {\n        regex: /&(inr|#8377);/g,\n        val: \"₹\"\n      }\n    };\n    this.addExternalEntities = addExternalEntities;\n    this.parseXml = parseXml;\n    this.parseTextData = parseTextData;\n    this.resolveNameSpace = resolveNameSpace;\n    this.buildAttributesMap = buildAttributesMap;\n    this.isItStopNode = isItStopNode;\n    this.replaceEntitiesValue = replaceEntitiesValue;\n    this.readStopNodeData = readStopNodeData;\n    this.saveTextToParentTag = saveTextToParentTag;\n    this.addChild = addChild;\n  }\n\n}\n\nfunction addExternalEntities(externalEntities) {\n  const entKeys = Object.keys(externalEntities);\n\n  for (let i = 0; i < entKeys.length; i++) {\n    const ent = entKeys[i];\n    this.lastEntities[ent] = {\n      regex: new RegExp(\"&\" + ent + \";\", \"g\"),\n      val: externalEntities[ent]\n    };\n  }\n}\n/**\n * @param {string} val\n * @param {string} tagName\n * @param {string} jPath\n * @param {boolean} dontTrim\n * @param {boolean} hasAttributes\n * @param {boolean} isLeafNode\n * @param {boolean} escapeEntities\n */\n\n\nfunction parseTextData(val, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {\n  if (val !== undefined) {\n    if (this.options.trimValues && !dontTrim) {\n      val = val.trim();\n    }\n\n    if (val.length > 0) {\n      if (!escapeEntities) val = this.replaceEntitiesValue(val);\n      const newval = this.options.tagValueProcessor(tagName, val, jPath, hasAttributes, isLeafNode);\n\n      if (newval === null || newval === undefined) {\n        //don't parse\n        return val;\n      } else if (typeof newval !== typeof val || newval !== val) {\n        //overwrite\n        return newval;\n      } else if (this.options.trimValues) {\n        return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);\n      } else {\n        const trimmedVal = val.trim();\n\n        if (trimmedVal === val) {\n          return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);\n        } else {\n          return val;\n        }\n      }\n    }\n  }\n}\n\nfunction resolveNameSpace(tagname) {\n  if (this.options.removeNSPrefix) {\n    const tags = tagname.split(':');\n    const prefix = tagname.charAt(0) === '/' ? '/' : '';\n\n    if (tags[0] === 'xmlns') {\n      return '';\n    }\n\n    if (tags.length === 2) {\n      tagname = prefix + tags[1];\n    }\n  }\n\n  return tagname;\n} //TODO: change regex to capture NS\n//const attrsRegx = new RegExp(\"([\\\\w\\\\-\\\\.\\\\:]+)\\\\s*=\\\\s*(['\\\"])((.|\\n)*?)\\\\2\",\"gm\");\n\n\nconst attrsRegx = new RegExp('([^\\\\s=]+)\\\\s*(=\\\\s*([\\'\"])([\\\\s\\\\S]*?)\\\\3)?', 'gm');\n\nfunction buildAttributesMap(attrStr, jPath, tagName) {\n  if (!this.options.ignoreAttributes && typeof attrStr === 'string') {\n    // attrStr = attrStr.replace(/\\r?\\n/g, ' ');\n    //attrStr = attrStr || attrStr.trim();\n    const matches = util.getAllMatches(attrStr, attrsRegx);\n    const len = matches.length; //don't make it inline\n\n    const attrs = {};\n\n    for (let i = 0; i < len; i++) {\n      const attrName = this.resolveNameSpace(matches[i][1]);\n      let oldVal = matches[i][4];\n      let aName = this.options.attributeNamePrefix + attrName;\n\n      if (attrName.length) {\n        if (this.options.transformAttributeName) {\n          aName = this.options.transformAttributeName(aName);\n        }\n\n        if (aName === \"__proto__\") aName = \"#__proto__\";\n\n        if (oldVal !== undefined) {\n          if (this.options.trimValues) {\n            oldVal = oldVal.trim();\n          }\n\n          oldVal = this.replaceEntitiesValue(oldVal);\n          const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);\n\n          if (newVal === null || newVal === undefined) {\n            //don't parse\n            attrs[aName] = oldVal;\n          } else if (typeof newVal !== typeof oldVal || newVal !== oldVal) {\n            //overwrite\n            attrs[aName] = newVal;\n          } else {\n            //parse\n            attrs[aName] = parseValue(oldVal, this.options.parseAttributeValue, this.options.numberParseOptions);\n          }\n        } else if (this.options.allowBooleanAttributes) {\n          attrs[aName] = true;\n        }\n      }\n    }\n\n    if (!Object.keys(attrs).length) {\n      return;\n    }\n\n    if (this.options.attributesGroupName) {\n      const attrCollection = {};\n      attrCollection[this.options.attributesGroupName] = attrs;\n      return attrCollection;\n    }\n\n    return attrs;\n  }\n}\n\nconst parseXml = function (xmlData) {\n  xmlData = xmlData.replace(/\\r\\n?/g, \"\\n\"); //TODO: remove this line\n\n  const xmlObj = new xmlNode('!xml');\n  let currentNode = xmlObj;\n  let textData = \"\";\n  let jPath = \"\";\n\n  for (let i = 0; i < xmlData.length; i++) {\n    //for each char in XML data\n    const ch = xmlData[i];\n\n    if (ch === '<') {\n      // const nextIndex = i+1;\n      // const _2ndChar = xmlData[nextIndex];\n      if (xmlData[i + 1] === '/') {\n        //Closing Tag\n        const closeIndex = findClosingIndex(xmlData, \">\", i, \"Closing Tag is not closed.\");\n        let tagName = xmlData.substring(i + 2, closeIndex).trim();\n\n        if (this.options.removeNSPrefix) {\n          const colonIndex = tagName.indexOf(\":\");\n\n          if (colonIndex !== -1) {\n            tagName = tagName.substr(colonIndex + 1);\n          }\n        }\n\n        if (this.options.transformTagName) {\n          tagName = this.options.transformTagName(tagName);\n        }\n\n        if (currentNode) {\n          textData = this.saveTextToParentTag(textData, currentNode, jPath);\n        } //check if last tag of nested tag was unpaired tag\n\n\n        const lastTagName = jPath.substring(jPath.lastIndexOf(\".\") + 1);\n\n        if (tagName && this.options.unpairedTags.indexOf(tagName) !== -1) {\n          throw new Error(`Unpaired tag can not be used as closing tag: </${tagName}>`);\n        }\n\n        let propIndex = 0;\n\n        if (lastTagName && this.options.unpairedTags.indexOf(lastTagName) !== -1) {\n          propIndex = jPath.lastIndexOf('.', jPath.lastIndexOf('.') - 1);\n          this.tagsNodeStack.pop();\n        } else {\n          propIndex = jPath.lastIndexOf(\".\");\n        }\n\n        jPath = jPath.substring(0, propIndex);\n        currentNode = this.tagsNodeStack.pop(); //avoid recursion, set the parent tag scope\n\n        textData = \"\";\n        i = closeIndex;\n      } else if (xmlData[i + 1] === '?') {\n        let tagData = readTagExp(xmlData, i, false, \"?>\");\n        if (!tagData) throw new Error(\"Pi Tag is not closed.\");\n        textData = this.saveTextToParentTag(textData, currentNode, jPath);\n\n        if (this.options.ignoreDeclaration && tagData.tagName === \"?xml\" || this.options.ignorePiTags) {} else {\n          const childNode = new xmlNode(tagData.tagName);\n          childNode.add(this.options.textNodeName, \"\");\n\n          if (tagData.tagName !== tagData.tagExp && tagData.attrExpPresent) {\n            childNode[\":@\"] = this.buildAttributesMap(tagData.tagExp, jPath, tagData.tagName);\n          }\n\n          this.addChild(currentNode, childNode, jPath);\n        }\n\n        i = tagData.closeIndex + 1;\n      } else if (xmlData.substr(i + 1, 3) === '!--') {\n        const endIndex = findClosingIndex(xmlData, \"-->\", i + 4, \"Comment is not closed.\");\n\n        if (this.options.commentPropName) {\n          const comment = xmlData.substring(i + 4, endIndex - 2);\n          textData = this.saveTextToParentTag(textData, currentNode, jPath);\n          currentNode.add(this.options.commentPropName, [{\n            [this.options.textNodeName]: comment\n          }]);\n        }\n\n        i = endIndex;\n      } else if (xmlData.substr(i + 1, 2) === '!D') {\n        const result = readDocType(xmlData, i);\n        this.docTypeEntities = result.entities;\n        i = result.i;\n      } else if (xmlData.substr(i + 1, 2) === '![') {\n        const closeIndex = findClosingIndex(xmlData, \"]]>\", i, \"CDATA is not closed.\") - 2;\n        const tagExp = xmlData.substring(i + 9, closeIndex);\n        textData = this.saveTextToParentTag(textData, currentNode, jPath); //cdata should be set even if it is 0 length string\n\n        if (this.options.cdataPropName) {\n          // let val = this.parseTextData(tagExp, this.options.cdataPropName, jPath + \".\" + this.options.cdataPropName, true, false, true);\n          // if(!val) val = \"\";\n          currentNode.add(this.options.cdataPropName, [{\n            [this.options.textNodeName]: tagExp\n          }]);\n        } else {\n          let val = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true);\n          if (val == undefined) val = \"\";\n          currentNode.add(this.options.textNodeName, val);\n        }\n\n        i = closeIndex + 2;\n      } else {\n        //Opening tag\n        let result = readTagExp(xmlData, i, this.options.removeNSPrefix);\n        let tagName = result.tagName;\n        let tagExp = result.tagExp;\n        let attrExpPresent = result.attrExpPresent;\n        let closeIndex = result.closeIndex;\n\n        if (this.options.transformTagName) {\n          tagName = this.options.transformTagName(tagName);\n        } //save text as child node\n\n\n        if (currentNode && textData) {\n          if (currentNode.tagname !== '!xml') {\n            //when nested tag is found\n            textData = this.saveTextToParentTag(textData, currentNode, jPath, false);\n          }\n        } //check if last tag was unpaired tag\n\n\n        const lastTag = currentNode;\n\n        if (lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1) {\n          currentNode = this.tagsNodeStack.pop();\n          jPath = jPath.substring(0, jPath.lastIndexOf(\".\"));\n        }\n\n        if (tagName !== xmlObj.tagname) {\n          jPath += jPath ? \".\" + tagName : tagName;\n        }\n\n        if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) {\n          //TODO: namespace\n          let tagContent = \"\"; //self-closing tag\n\n          if (tagExp.length > 0 && tagExp.lastIndexOf(\"/\") === tagExp.length - 1) {\n            i = result.closeIndex;\n          } //unpaired tag\n          else if (this.options.unpairedTags.indexOf(tagName) !== -1) {\n            i = result.closeIndex;\n          } //normal tag\n          else {\n            //read until closing tag is found\n            const result = this.readStopNodeData(xmlData, tagName, closeIndex + 1);\n            if (!result) throw new Error(`Unexpected end of ${tagName}`);\n            i = result.i;\n            tagContent = result.tagContent;\n          }\n\n          const childNode = new xmlNode(tagName);\n\n          if (tagName !== tagExp && attrExpPresent) {\n            childNode[\":@\"] = this.buildAttributesMap(tagExp, jPath, tagName);\n          }\n\n          if (tagContent) {\n            tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);\n          }\n\n          jPath = jPath.substr(0, jPath.lastIndexOf(\".\"));\n          childNode.add(this.options.textNodeName, tagContent);\n          this.addChild(currentNode, childNode, jPath);\n        } else {\n          //selfClosing tag\n          if (tagExp.length > 0 && tagExp.lastIndexOf(\"/\") === tagExp.length - 1) {\n            if (tagName[tagName.length - 1] === \"/\") {\n              //remove trailing '/'\n              tagName = tagName.substr(0, tagName.length - 1);\n              jPath = jPath.substr(0, jPath.length - 1);\n              tagExp = tagName;\n            } else {\n              tagExp = tagExp.substr(0, tagExp.length - 1);\n            }\n\n            if (this.options.transformTagName) {\n              tagName = this.options.transformTagName(tagName);\n            }\n\n            const childNode = new xmlNode(tagName);\n\n            if (tagName !== tagExp && attrExpPresent) {\n              childNode[\":@\"] = this.buildAttributesMap(tagExp, jPath, tagName);\n            }\n\n            this.addChild(currentNode, childNode, jPath);\n            jPath = jPath.substr(0, jPath.lastIndexOf(\".\"));\n          } //opening tag\n          else {\n            const childNode = new xmlNode(tagName);\n            this.tagsNodeStack.push(currentNode);\n\n            if (tagName !== tagExp && attrExpPresent) {\n              childNode[\":@\"] = this.buildAttributesMap(tagExp, jPath, tagName);\n            }\n\n            this.addChild(currentNode, childNode, jPath);\n            currentNode = childNode;\n          }\n\n          textData = \"\";\n          i = closeIndex;\n        }\n      }\n    } else {\n      textData += xmlData[i];\n    }\n  }\n\n  return xmlObj.child;\n};\n\nfunction addChild(currentNode, childNode, jPath) {\n  const result = this.options.updateTag(childNode.tagname, jPath, childNode[\":@\"]);\n\n  if (result === false) {} else if (typeof result === \"string\") {\n    childNode.tagname = result;\n    currentNode.addChild(childNode);\n  } else {\n    currentNode.addChild(childNode);\n  }\n}\n\nconst replaceEntitiesValue = function (val) {\n  if (this.options.processEntities) {\n    for (let entityName in this.docTypeEntities) {\n      const entity = this.docTypeEntities[entityName];\n      val = val.replace(entity.regx, entity.val);\n    }\n\n    for (let entityName in this.lastEntities) {\n      const entity = this.lastEntities[entityName];\n      val = val.replace(entity.regex, entity.val);\n    }\n\n    if (this.options.htmlEntities) {\n      for (let entityName in this.htmlEntities) {\n        const entity = this.htmlEntities[entityName];\n        val = val.replace(entity.regex, entity.val);\n      }\n    }\n\n    val = val.replace(this.ampEntity.regex, this.ampEntity.val);\n  }\n\n  return val;\n};\n\nfunction saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {\n  if (textData) {\n    //store previously collected data as textNode\n    if (isLeafNode === undefined) isLeafNode = Object.keys(currentNode.child).length === 0;\n    textData = this.parseTextData(textData, currentNode.tagname, jPath, false, currentNode[\":@\"] ? Object.keys(currentNode[\":@\"]).length !== 0 : false, isLeafNode);\n    if (textData !== undefined && textData !== \"\") currentNode.add(this.options.textNodeName, textData);\n    textData = \"\";\n  }\n\n  return textData;\n} //TODO: use jPath to simplify the logic\n\n/**\n * \n * @param {string[]} stopNodes \n * @param {string} jPath\n * @param {string} currentTagName \n */\n\n\nfunction isItStopNode(stopNodes, jPath, currentTagName) {\n  const allNodesExp = \"*.\" + currentTagName;\n\n  for (const stopNodePath in stopNodes) {\n    const stopNodeExp = stopNodes[stopNodePath];\n    if (allNodesExp === stopNodeExp || jPath === stopNodeExp) return true;\n  }\n\n  return false;\n}\n/**\n * Returns the tag Expression and where it is ending handling single-double quotes situation\n * @param {string} xmlData \n * @param {number} i starting index\n * @returns \n */\n\n\nfunction tagExpWithClosingIndex(xmlData, i, closingChar = \">\") {\n  let attrBoundary;\n  let tagExp = \"\";\n\n  for (let index = i; index < xmlData.length; index++) {\n    let ch = xmlData[index];\n\n    if (attrBoundary) {\n      if (ch === attrBoundary) attrBoundary = \"\"; //reset\n    } else if (ch === '\"' || ch === \"'\") {\n      attrBoundary = ch;\n    } else if (ch === closingChar[0]) {\n      if (closingChar[1]) {\n        if (xmlData[index + 1] === closingChar[1]) {\n          return {\n            data: tagExp,\n            index: index\n          };\n        }\n      } else {\n        return {\n          data: tagExp,\n          index: index\n        };\n      }\n    } else if (ch === '\\t') {\n      ch = \" \";\n    }\n\n    tagExp += ch;\n  }\n}\n\nfunction findClosingIndex(xmlData, str, i, errMsg) {\n  const closingIndex = xmlData.indexOf(str, i);\n\n  if (closingIndex === -1) {\n    throw new Error(errMsg);\n  } else {\n    return closingIndex + str.length - 1;\n  }\n}\n\nfunction readTagExp(xmlData, i, removeNSPrefix, closingChar = \">\") {\n  const result = tagExpWithClosingIndex(xmlData, i + 1, closingChar);\n  if (!result) return;\n  let tagExp = result.data;\n  const closeIndex = result.index;\n  const separatorIndex = tagExp.search(/\\s/);\n  let tagName = tagExp;\n  let attrExpPresent = true;\n\n  if (separatorIndex !== -1) {\n    //separate tag name and attributes expression\n    tagName = tagExp.substr(0, separatorIndex).replace(/\\s\\s*$/, '');\n    tagExp = tagExp.substr(separatorIndex + 1);\n  }\n\n  if (removeNSPrefix) {\n    const colonIndex = tagName.indexOf(\":\");\n\n    if (colonIndex !== -1) {\n      tagName = tagName.substr(colonIndex + 1);\n      attrExpPresent = tagName !== result.data.substr(colonIndex + 1);\n    }\n  }\n\n  return {\n    tagName: tagName,\n    tagExp: tagExp,\n    closeIndex: closeIndex,\n    attrExpPresent: attrExpPresent\n  };\n}\n/**\n * find paired tag for a stop node\n * @param {string} xmlData \n * @param {string} tagName \n * @param {number} i \n */\n\n\nfunction readStopNodeData(xmlData, tagName, i) {\n  const startIndex = i; // Starting at 1 since we already have an open tag\n\n  let openTagCount = 1;\n\n  for (; i < xmlData.length; i++) {\n    if (xmlData[i] === \"<\") {\n      if (xmlData[i + 1] === \"/\") {\n        //close tag\n        const closeIndex = findClosingIndex(xmlData, \">\", i, `${tagName} is not closed`);\n        let closeTagName = xmlData.substring(i + 2, closeIndex).trim();\n\n        if (closeTagName === tagName) {\n          openTagCount--;\n\n          if (openTagCount === 0) {\n            return {\n              tagContent: xmlData.substring(startIndex, i),\n              i: closeIndex\n            };\n          }\n        }\n\n        i = closeIndex;\n      } else if (xmlData[i + 1] === '?') {\n        const closeIndex = findClosingIndex(xmlData, \"?>\", i + 1, \"StopNode is not closed.\");\n        i = closeIndex;\n      } else if (xmlData.substr(i + 1, 3) === '!--') {\n        const closeIndex = findClosingIndex(xmlData, \"-->\", i + 3, \"StopNode is not closed.\");\n        i = closeIndex;\n      } else if (xmlData.substr(i + 1, 2) === '![') {\n        const closeIndex = findClosingIndex(xmlData, \"]]>\", i, \"StopNode is not closed.\") - 2;\n        i = closeIndex;\n      } else {\n        const tagData = readTagExp(xmlData, i, '>');\n\n        if (tagData) {\n          const openTagName = tagData && tagData.tagName;\n\n          if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length - 1] !== \"/\") {\n            openTagCount++;\n          }\n\n          i = tagData.closeIndex;\n        }\n      }\n    }\n  } //end for loop\n\n}\n\nfunction parseValue(val, shouldParse, options) {\n  if (shouldParse && typeof val === 'string') {\n    //console.log(options)\n    const newval = val.trim();\n    if (newval === 'true') return true;else if (newval === 'false') return false;else return toNumber(val, options);\n  } else {\n    if (util.isExist(val)) {\n      return val;\n    } else {\n      return '';\n    }\n  }\n}\n\nmodule.exports = OrderedObjParser;","map":{"version":3,"names":["util","require","xmlNode","readDocType","toNumber","regx","replace","nameRegexp","OrderedObjParser","constructor","options","currentNode","tagsNodeStack","docTypeEntities","lastEntities","regex","val","ampEntity","htmlEntities","addExternalEntities","parseXml","parseTextData","resolveNameSpace","buildAttributesMap","isItStopNode","replaceEntitiesValue","readStopNodeData","saveTextToParentTag","addChild","externalEntities","entKeys","Object","keys","i","length","ent","RegExp","tagName","jPath","dontTrim","hasAttributes","isLeafNode","escapeEntities","undefined","trimValues","trim","newval","tagValueProcessor","parseValue","parseTagValue","numberParseOptions","trimmedVal","tagname","removeNSPrefix","tags","split","prefix","charAt","attrsRegx","attrStr","ignoreAttributes","matches","getAllMatches","len","attrs","attrName","oldVal","aName","attributeNamePrefix","transformAttributeName","newVal","attributeValueProcessor","parseAttributeValue","allowBooleanAttributes","attributesGroupName","attrCollection","xmlData","xmlObj","textData","ch","closeIndex","findClosingIndex","substring","colonIndex","indexOf","substr","transformTagName","lastTagName","lastIndexOf","unpairedTags","Error","propIndex","pop","tagData","readTagExp","ignoreDeclaration","ignorePiTags","childNode","add","textNodeName","tagExp","attrExpPresent","endIndex","commentPropName","comment","result","entities","cdataPropName","lastTag","stopNodes","tagContent","push","child","updateTag","processEntities","entityName","entity","currentTagName","allNodesExp","stopNodePath","stopNodeExp","tagExpWithClosingIndex","closingChar","attrBoundary","index","data","str","errMsg","closingIndex","separatorIndex","search","startIndex","openTagCount","closeTagName","openTagName","shouldParse","isExist","module","exports"],"sources":["/home/alexandre/projetos/uploadfile-web/node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js"],"sourcesContent":["'use strict';\n///@ts-check\n\nconst util = require('../util');\nconst xmlNode = require('./xmlNode');\nconst readDocType = require(\"./DocTypeReader\");\nconst toNumber = require(\"strnum\");\n\nconst regx =\n  '<((!\\\\[CDATA\\\\[([\\\\s\\\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\\\/)(NAME)\\\\s*>))([^<]*)'\n  .replace(/NAME/g, util.nameRegexp);\n\n//const tagsRegx = new RegExp(\"<(\\\\/?[\\\\w:\\\\-\\._]+)([^>]*)>(\\\\s*\"+cdataRegx+\")*([^<]+)?\",\"g\");\n//const tagsRegx = new RegExp(\"<(\\\\/?)((\\\\w*:)?([\\\\w:\\\\-\\._]+))([^>]*)>([^<]*)(\"+cdataRegx+\"([^<]*))*([^<]+)?\",\"g\");\n\nclass OrderedObjParser{\n  constructor(options){\n    this.options = options;\n    this.currentNode = null;\n    this.tagsNodeStack = [];\n    this.docTypeEntities = {};\n    this.lastEntities = {\n      \"apos\" : { regex: /&(apos|#39|#x27);/g, val : \"'\"},\n      \"gt\" : { regex: /&(gt|#62|#x3E);/g, val : \">\"},\n      \"lt\" : { regex: /&(lt|#60|#x3C);/g, val : \"<\"},\n      \"quot\" : { regex: /&(quot|#34|#x22);/g, val : \"\\\"\"},\n    };\n    this.ampEntity = { regex: /&(amp|#38|#x26);/g, val : \"&\"};\n    this.htmlEntities = {\n      \"space\": { regex: /&(nbsp|#160);/g, val: \" \" },\n      // \"lt\" : { regex: /&(lt|#60);/g, val: \"<\" },\n      // \"gt\" : { regex: /&(gt|#62);/g, val: \">\" },\n      // \"amp\" : { regex: /&(amp|#38);/g, val: \"&\" },\n      // \"quot\" : { regex: /&(quot|#34);/g, val: \"\\\"\" },\n      // \"apos\" : { regex: /&(apos|#39);/g, val: \"'\" },\n      \"cent\" : { regex: /&(cent|#162);/g, val: \"¢\" },\n      \"pound\" : { regex: /&(pound|#163);/g, val: \"£\" },\n      \"yen\" : { regex: /&(yen|#165);/g, val: \"¥\" },\n      \"euro\" : { regex: /&(euro|#8364);/g, val: \"€\" },\n      \"copyright\" : { regex: /&(copy|#169);/g, val: \"©\" },\n      \"reg\" : { regex: /&(reg|#174);/g, val: \"®\" },\n      \"inr\" : { regex: /&(inr|#8377);/g, val: \"₹\" },\n    };\n    this.addExternalEntities = addExternalEntities;\n    this.parseXml = parseXml;\n    this.parseTextData = parseTextData;\n    this.resolveNameSpace = resolveNameSpace;\n    this.buildAttributesMap = buildAttributesMap;\n    this.isItStopNode = isItStopNode;\n    this.replaceEntitiesValue = replaceEntitiesValue;\n    this.readStopNodeData = readStopNodeData;\n    this.saveTextToParentTag = saveTextToParentTag;\n    this.addChild = addChild;\n  }\n\n}\n\nfunction addExternalEntities(externalEntities){\n  const entKeys = Object.keys(externalEntities);\n  for (let i = 0; i < entKeys.length; i++) {\n    const ent = entKeys[i];\n    this.lastEntities[ent] = {\n       regex: new RegExp(\"&\"+ent+\";\",\"g\"),\n       val : externalEntities[ent]\n    }\n  }\n}\n\n/**\n * @param {string} val\n * @param {string} tagName\n * @param {string} jPath\n * @param {boolean} dontTrim\n * @param {boolean} hasAttributes\n * @param {boolean} isLeafNode\n * @param {boolean} escapeEntities\n */\nfunction parseTextData(val, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {\n  if (val !== undefined) {\n    if (this.options.trimValues && !dontTrim) {\n      val = val.trim();\n    }\n    if(val.length > 0){\n      if(!escapeEntities) val = this.replaceEntitiesValue(val);\n      \n      const newval = this.options.tagValueProcessor(tagName, val, jPath, hasAttributes, isLeafNode);\n      if(newval === null || newval === undefined){\n        //don't parse\n        return val;\n      }else if(typeof newval !== typeof val || newval !== val){\n        //overwrite\n        return newval;\n      }else if(this.options.trimValues){\n        return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);\n      }else{\n        const trimmedVal = val.trim();\n        if(trimmedVal === val){\n          return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);\n        }else{\n          return val;\n        }\n      }\n    }\n  }\n}\n\nfunction resolveNameSpace(tagname) {\n  if (this.options.removeNSPrefix) {\n    const tags = tagname.split(':');\n    const prefix = tagname.charAt(0) === '/' ? '/' : '';\n    if (tags[0] === 'xmlns') {\n      return '';\n    }\n    if (tags.length === 2) {\n      tagname = prefix + tags[1];\n    }\n  }\n  return tagname;\n}\n\n//TODO: change regex to capture NS\n//const attrsRegx = new RegExp(\"([\\\\w\\\\-\\\\.\\\\:]+)\\\\s*=\\\\s*(['\\\"])((.|\\n)*?)\\\\2\",\"gm\");\nconst attrsRegx = new RegExp('([^\\\\s=]+)\\\\s*(=\\\\s*([\\'\"])([\\\\s\\\\S]*?)\\\\3)?', 'gm');\n\nfunction buildAttributesMap(attrStr, jPath, tagName) {\n  if (!this.options.ignoreAttributes && typeof attrStr === 'string') {\n    // attrStr = attrStr.replace(/\\r?\\n/g, ' ');\n    //attrStr = attrStr || attrStr.trim();\n\n    const matches = util.getAllMatches(attrStr, attrsRegx);\n    const len = matches.length; //don't make it inline\n    const attrs = {};\n    for (let i = 0; i < len; i++) {\n      const attrName = this.resolveNameSpace(matches[i][1]);\n      let oldVal = matches[i][4];\n      let aName = this.options.attributeNamePrefix + attrName;\n      if (attrName.length) {\n        if (this.options.transformAttributeName) {\n          aName = this.options.transformAttributeName(aName);\n        }\n        if(aName === \"__proto__\") aName  = \"#__proto__\";\n        if (oldVal !== undefined) {\n          if (this.options.trimValues) {\n            oldVal = oldVal.trim();\n          }\n          oldVal = this.replaceEntitiesValue(oldVal);\n          const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);\n          if(newVal === null || newVal === undefined){\n            //don't parse\n            attrs[aName] = oldVal;\n          }else if(typeof newVal !== typeof oldVal || newVal !== oldVal){\n            //overwrite\n            attrs[aName] = newVal;\n          }else{\n            //parse\n            attrs[aName] = parseValue(\n              oldVal,\n              this.options.parseAttributeValue,\n              this.options.numberParseOptions\n            );\n          }\n        } else if (this.options.allowBooleanAttributes) {\n          attrs[aName] = true;\n        }\n      }\n    }\n    if (!Object.keys(attrs).length) {\n      return;\n    }\n    if (this.options.attributesGroupName) {\n      const attrCollection = {};\n      attrCollection[this.options.attributesGroupName] = attrs;\n      return attrCollection;\n    }\n    return attrs\n  }\n}\n\nconst parseXml = function(xmlData) {\n  xmlData = xmlData.replace(/\\r\\n?/g, \"\\n\"); //TODO: remove this line\n  const xmlObj = new xmlNode('!xml');\n  let currentNode = xmlObj;\n  let textData = \"\";\n  let jPath = \"\";\n  for(let i=0; i< xmlData.length; i++){//for each char in XML data\n    const ch = xmlData[i];\n    if(ch === '<'){\n      // const nextIndex = i+1;\n      // const _2ndChar = xmlData[nextIndex];\n      if( xmlData[i+1] === '/') {//Closing Tag\n        const closeIndex = findClosingIndex(xmlData, \">\", i, \"Closing Tag is not closed.\")\n        let tagName = xmlData.substring(i+2,closeIndex).trim();\n\n        if(this.options.removeNSPrefix){\n          const colonIndex = tagName.indexOf(\":\");\n          if(colonIndex !== -1){\n            tagName = tagName.substr(colonIndex+1);\n          }\n        }\n\n        if(this.options.transformTagName) {\n          tagName = this.options.transformTagName(tagName);\n        }\n\n        if(currentNode){\n          textData = this.saveTextToParentTag(textData, currentNode, jPath);\n        }\n\n        //check if last tag of nested tag was unpaired tag\n        const lastTagName = jPath.substring(jPath.lastIndexOf(\".\")+1);\n        if(tagName && this.options.unpairedTags.indexOf(tagName) !== -1 ){\n          throw new Error(`Unpaired tag can not be used as closing tag: </${tagName}>`);\n        }\n        let propIndex = 0\n        if(lastTagName && this.options.unpairedTags.indexOf(lastTagName) !== -1 ){\n          propIndex = jPath.lastIndexOf('.', jPath.lastIndexOf('.')-1)\n          this.tagsNodeStack.pop();\n        }else{\n          propIndex = jPath.lastIndexOf(\".\");\n        }\n        jPath = jPath.substring(0, propIndex);\n\n        currentNode = this.tagsNodeStack.pop();//avoid recursion, set the parent tag scope\n        textData = \"\";\n        i = closeIndex;\n      } else if( xmlData[i+1] === '?') {\n\n        let tagData = readTagExp(xmlData,i, false, \"?>\");\n        if(!tagData) throw new Error(\"Pi Tag is not closed.\");\n\n        textData = this.saveTextToParentTag(textData, currentNode, jPath);\n        if( (this.options.ignoreDeclaration && tagData.tagName === \"?xml\") || this.options.ignorePiTags){\n\n        }else{\n  \n          const childNode = new xmlNode(tagData.tagName);\n          childNode.add(this.options.textNodeName, \"\");\n          \n          if(tagData.tagName !== tagData.tagExp && tagData.attrExpPresent){\n            childNode[\":@\"] = this.buildAttributesMap(tagData.tagExp, jPath, tagData.tagName);\n          }\n          this.addChild(currentNode, childNode, jPath)\n\n        }\n\n\n        i = tagData.closeIndex + 1;\n      } else if(xmlData.substr(i + 1, 3) === '!--') {\n        const endIndex = findClosingIndex(xmlData, \"-->\", i+4, \"Comment is not closed.\")\n        if(this.options.commentPropName){\n          const comment = xmlData.substring(i + 4, endIndex - 2);\n\n          textData = this.saveTextToParentTag(textData, currentNode, jPath);\n\n          currentNode.add(this.options.commentPropName, [ { [this.options.textNodeName] : comment } ]);\n        }\n        i = endIndex;\n      } else if( xmlData.substr(i + 1, 2) === '!D') {\n        const result = readDocType(xmlData, i);\n        this.docTypeEntities = result.entities;\n        i = result.i;\n      }else if(xmlData.substr(i + 1, 2) === '![') {\n        const closeIndex = findClosingIndex(xmlData, \"]]>\", i, \"CDATA is not closed.\") - 2;\n        const tagExp = xmlData.substring(i + 9,closeIndex);\n\n        textData = this.saveTextToParentTag(textData, currentNode, jPath);\n\n        //cdata should be set even if it is 0 length string\n        if(this.options.cdataPropName){\n          // let val = this.parseTextData(tagExp, this.options.cdataPropName, jPath + \".\" + this.options.cdataPropName, true, false, true);\n          // if(!val) val = \"\";\n          currentNode.add(this.options.cdataPropName, [ { [this.options.textNodeName] : tagExp } ]);\n        }else{\n          let val = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true);\n          if(val == undefined) val = \"\";\n          currentNode.add(this.options.textNodeName, val);\n        }\n        \n        i = closeIndex + 2;\n      }else {//Opening tag\n        let result = readTagExp(xmlData,i, this.options.removeNSPrefix);\n        let tagName= result.tagName;\n        let tagExp = result.tagExp;\n        let attrExpPresent = result.attrExpPresent;\n        let closeIndex = result.closeIndex;\n\n        if (this.options.transformTagName) {\n          tagName = this.options.transformTagName(tagName);\n        }\n        \n        //save text as child node\n        if (currentNode && textData) {\n          if(currentNode.tagname !== '!xml'){\n            //when nested tag is found\n            textData = this.saveTextToParentTag(textData, currentNode, jPath, false);\n          }\n        }\n\n        //check if last tag was unpaired tag\n        const lastTag = currentNode;\n        if(lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1 ){\n          currentNode = this.tagsNodeStack.pop();\n          jPath = jPath.substring(0, jPath.lastIndexOf(\".\"));\n        }\n        if(tagName !== xmlObj.tagname){\n          jPath += jPath ? \".\" + tagName : tagName;\n        }\n        if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) { //TODO: namespace\n          let tagContent = \"\";\n          //self-closing tag\n          if(tagExp.length > 0 && tagExp.lastIndexOf(\"/\") === tagExp.length - 1){\n            i = result.closeIndex;\n          }\n          //unpaired tag\n          else if(this.options.unpairedTags.indexOf(tagName) !== -1){\n            i = result.closeIndex;\n          }\n          //normal tag\n          else{\n            //read until closing tag is found\n            const result = this.readStopNodeData(xmlData, tagName, closeIndex + 1);\n            if(!result) throw new Error(`Unexpected end of ${tagName}`);\n            i = result.i;\n            tagContent = result.tagContent;\n          }\n\n          const childNode = new xmlNode(tagName);\n          if(tagName !== tagExp && attrExpPresent){\n            childNode[\":@\"] = this.buildAttributesMap(tagExp, jPath, tagName);\n          }\n          if(tagContent) {\n            tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);\n          }\n          \n          jPath = jPath.substr(0, jPath.lastIndexOf(\".\"));\n          childNode.add(this.options.textNodeName, tagContent);\n          \n          this.addChild(currentNode, childNode, jPath)\n        }else{\n  //selfClosing tag\n          if(tagExp.length > 0 && tagExp.lastIndexOf(\"/\") === tagExp.length - 1){\n            if(tagName[tagName.length - 1] === \"/\"){ //remove trailing '/'\n              tagName = tagName.substr(0, tagName.length - 1);\n              jPath = jPath.substr(0, jPath.length - 1);\n              tagExp = tagName;\n            }else{\n              tagExp = tagExp.substr(0, tagExp.length - 1);\n            }\n            \n            if(this.options.transformTagName) {\n              tagName = this.options.transformTagName(tagName);\n            }\n\n            const childNode = new xmlNode(tagName);\n            if(tagName !== tagExp && attrExpPresent){\n              childNode[\":@\"] = this.buildAttributesMap(tagExp, jPath, tagName);\n            }\n            this.addChild(currentNode, childNode, jPath)\n            jPath = jPath.substr(0, jPath.lastIndexOf(\".\"));\n          }\n    //opening tag\n          else{\n            const childNode = new xmlNode( tagName);\n            this.tagsNodeStack.push(currentNode);\n            \n            if(tagName !== tagExp && attrExpPresent){\n              childNode[\":@\"] = this.buildAttributesMap(tagExp, jPath, tagName);\n            }\n            this.addChild(currentNode, childNode, jPath)\n            currentNode = childNode;\n          }\n          textData = \"\";\n          i = closeIndex;\n        }\n      }\n    }else{\n      textData += xmlData[i];\n    }\n  }\n  return xmlObj.child;\n}\n\nfunction addChild(currentNode, childNode, jPath){\n  const result = this.options.updateTag(childNode.tagname, jPath, childNode[\":@\"])\n  if(result === false){\n  }else if(typeof result === \"string\"){\n    childNode.tagname = result\n    currentNode.addChild(childNode);\n  }else{\n    currentNode.addChild(childNode);\n  }\n}\n\nconst replaceEntitiesValue = function(val){\n\n  if(this.options.processEntities){\n    for(let entityName in this.docTypeEntities){\n      const entity = this.docTypeEntities[entityName];\n      val = val.replace( entity.regx, entity.val);\n    }\n    for(let entityName in this.lastEntities){\n      const entity = this.lastEntities[entityName];\n      val = val.replace( entity.regex, entity.val);\n    }\n    if(this.options.htmlEntities){\n      for(let entityName in this.htmlEntities){\n        const entity = this.htmlEntities[entityName];\n        val = val.replace( entity.regex, entity.val);\n      }\n    }\n    val = val.replace( this.ampEntity.regex, this.ampEntity.val);\n  }\n  return val;\n}\nfunction saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {\n  if (textData) { //store previously collected data as textNode\n    if(isLeafNode === undefined) isLeafNode = Object.keys(currentNode.child).length === 0\n    \n    textData = this.parseTextData(textData,\n      currentNode.tagname,\n      jPath,\n      false,\n      currentNode[\":@\"] ? Object.keys(currentNode[\":@\"]).length !== 0 : false,\n      isLeafNode);\n\n    if (textData !== undefined && textData !== \"\")\n      currentNode.add(this.options.textNodeName, textData);\n    textData = \"\";\n  }\n  return textData;\n}\n\n//TODO: use jPath to simplify the logic\n/**\n * \n * @param {string[]} stopNodes \n * @param {string} jPath\n * @param {string} currentTagName \n */\nfunction isItStopNode(stopNodes, jPath, currentTagName){\n  const allNodesExp = \"*.\" + currentTagName;\n  for (const stopNodePath in stopNodes) {\n    const stopNodeExp = stopNodes[stopNodePath];\n    if( allNodesExp === stopNodeExp || jPath === stopNodeExp  ) return true;\n  }\n  return false;\n}\n\n/**\n * Returns the tag Expression and where it is ending handling single-double quotes situation\n * @param {string} xmlData \n * @param {number} i starting index\n * @returns \n */\nfunction tagExpWithClosingIndex(xmlData, i, closingChar = \">\"){\n  let attrBoundary;\n  let tagExp = \"\";\n  for (let index = i; index < xmlData.length; index++) {\n    let ch = xmlData[index];\n    if (attrBoundary) {\n        if (ch === attrBoundary) attrBoundary = \"\";//reset\n    } else if (ch === '\"' || ch === \"'\") {\n        attrBoundary = ch;\n    } else if (ch === closingChar[0]) {\n      if(closingChar[1]){\n        if(xmlData[index + 1] === closingChar[1]){\n          return {\n            data: tagExp,\n            index: index\n          }\n        }\n      }else{\n        return {\n          data: tagExp,\n          index: index\n        }\n      }\n    } else if (ch === '\\t') {\n      ch = \" \"\n    }\n    tagExp += ch;\n  }\n}\n\nfunction findClosingIndex(xmlData, str, i, errMsg){\n  const closingIndex = xmlData.indexOf(str, i);\n  if(closingIndex === -1){\n    throw new Error(errMsg)\n  }else{\n    return closingIndex + str.length - 1;\n  }\n}\n\nfunction readTagExp(xmlData,i, removeNSPrefix, closingChar = \">\"){\n  const result = tagExpWithClosingIndex(xmlData, i+1, closingChar);\n  if(!result) return;\n  let tagExp = result.data;\n  const closeIndex = result.index;\n  const separatorIndex = tagExp.search(/\\s/);\n  let tagName = tagExp;\n  let attrExpPresent = true;\n  if(separatorIndex !== -1){//separate tag name and attributes expression\n    tagName = tagExp.substr(0, separatorIndex).replace(/\\s\\s*$/, '');\n    tagExp = tagExp.substr(separatorIndex + 1);\n  }\n\n  if(removeNSPrefix){\n    const colonIndex = tagName.indexOf(\":\");\n    if(colonIndex !== -1){\n      tagName = tagName.substr(colonIndex+1);\n      attrExpPresent = tagName !== result.data.substr(colonIndex + 1);\n    }\n  }\n\n  return {\n    tagName: tagName,\n    tagExp: tagExp,\n    closeIndex: closeIndex,\n    attrExpPresent: attrExpPresent,\n  }\n}\n/**\n * find paired tag for a stop node\n * @param {string} xmlData \n * @param {string} tagName \n * @param {number} i \n */\nfunction readStopNodeData(xmlData, tagName, i){\n  const startIndex = i;\n  // Starting at 1 since we already have an open tag\n  let openTagCount = 1;\n\n  for (; i < xmlData.length; i++) {\n    if( xmlData[i] === \"<\"){ \n      if (xmlData[i+1] === \"/\") {//close tag\n          const closeIndex = findClosingIndex(xmlData, \">\", i, `${tagName} is not closed`);\n          let closeTagName = xmlData.substring(i+2,closeIndex).trim();\n          if(closeTagName === tagName){\n            openTagCount--;\n            if (openTagCount === 0) {\n              return {\n                tagContent: xmlData.substring(startIndex, i),\n                i : closeIndex\n              }\n            }\n          }\n          i=closeIndex;\n        } else if(xmlData[i+1] === '?') { \n          const closeIndex = findClosingIndex(xmlData, \"?>\", i+1, \"StopNode is not closed.\")\n          i=closeIndex;\n        } else if(xmlData.substr(i + 1, 3) === '!--') { \n          const closeIndex = findClosingIndex(xmlData, \"-->\", i+3, \"StopNode is not closed.\")\n          i=closeIndex;\n        } else if(xmlData.substr(i + 1, 2) === '![') { \n          const closeIndex = findClosingIndex(xmlData, \"]]>\", i, \"StopNode is not closed.\") - 2;\n          i=closeIndex;\n        } else {\n          const tagData = readTagExp(xmlData, i, '>')\n\n          if (tagData) {\n            const openTagName = tagData && tagData.tagName;\n            if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length-1] !== \"/\") {\n              openTagCount++;\n            }\n            i=tagData.closeIndex;\n          }\n        }\n      }\n  }//end for loop\n}\n\nfunction parseValue(val, shouldParse, options) {\n  if (shouldParse && typeof val === 'string') {\n    //console.log(options)\n    const newval = val.trim();\n    if(newval === 'true' ) return true;\n    else if(newval === 'false' ) return false;\n    else return toNumber(val, options);\n  } else {\n    if (util.isExist(val)) {\n      return val;\n    } else {\n      return '';\n    }\n  }\n}\n\n\nmodule.exports = OrderedObjParser;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}